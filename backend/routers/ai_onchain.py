"""
AI On-Chain Action Builder.

Takes natural language descriptions and generates Solana program instructions.
"""

from fastapi import APIRouter, HTTPException
from typing import Dict, Any, List, Optional
from pydantic import BaseModel, Field
import logging
import httpx
import json

from config import settings

logger = logging.getLogger(__name__)

router = APIRouter()


class OnChainActionRequest(BaseModel):
    """Request model for AI on-chain action generation"""
    description: str = Field(..., min_length=1, max_length=2000, description="Natural language description of the on-chain action")
    action_type: str = Field(default="create_pool", description="Type of action: create_pool, join_pool, etc.")


class InstructionData(BaseModel):
    """Generated instruction data"""
    instruction_type: str
    accounts: List[Dict[str, str]]
    data: Dict[str, Any]
    description: str


class OnChainActionResponse(BaseModel):
    """Response model for generated on-chain action"""
    instruction: InstructionData
    estimated_fee: float
    required_signer: str
    warnings: List[str] = []


class ChallengeParseRequest(BaseModel):
    """Request model for AI-generated challenge blueprints."""
    description: str = Field(
        ...,
        min_length=1,
        max_length=2000,
        description="High-level natural language description of the challenge",
    )
    challenge_type: str = Field(
        ...,
        description="Frontend-selected challenge category label (e.g. 'Lifestyle (Photo/GPS)', 'Crypto (On-Chain)', 'Developer (GitHub)')",
    )


class ChallengeBlueprint(BaseModel):
    """
    Structured challenge blueprint generated by AI.

    This is intentionally close to the existing goal_type / goal_metadata
    shape so the frontend can thread it directly into pool creation without
    extra transformation.
    """

    canonical_name: str = Field(..., max_length=100)
    short_description: str = Field(..., max_length=200)
    detailed_description: Optional[str] = Field(
        None, description="Optional longer description for pool detail views"
    )
    challenge_type: str = Field(
        ...,
        description="Normalized challenge family: lifestyle | crypto | developer",
    )
    goal_type: str = Field(
        ...,
        description="Goal type for on-chain + agent logic (e.g. 'lifestyle_habit', 'hodl_token')",
    )
    goal_metadata: Dict[str, Any] = Field(
        ...,
        description="Goal-specific metadata; must be compatible with existing agent logic",
    )
    suggested_stake_amount: float = Field(..., gt=0)
    suggested_duration_days: int = Field(..., ge=1, le=60)
    suggested_recruitment_hours: int = Field(..., ge=0, le=168)
    suggested_max_participants: int = Field(..., ge=1, le=1000)
    suggested_min_participants: int = Field(..., ge=1)
    verification_summary: Optional[str] = Field(
        None,
        description="One-line summary of how verification works; surfaced in UI & tweets",
    )
    tweet_hook: Optional[str] = Field(
        None,
        description="Very short phrase that makes tweets more compelling (e.g. '6am gym selfie for 30 days')",
    )


async def _call_llm(prompt: str) -> str:
    """Call LLM API to generate instruction data"""
    api_url = getattr(settings, "LLM_API_URL", None)
    api_key = getattr(settings, "LLM_API_KEY", None)

    if not api_url or not api_key:
        raise HTTPException(
            status_code=500,
            detail="LLM_API_URL and LLM_API_KEY must be configured for AI on-chain actions"
        )

    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
    }

    payload = {
        "model": getattr(settings, "LLM_MODEL", "gpt-4o-mini"),
        "messages": [
            {
                "role": "system",
                "content": (
                    "You are an expert Solana developer. Generate exact instruction data for Solana program calls. "
                    "Respond with STRICT JSON ONLY, no explanations."
                ),
            },
            {"role": "user", "content": prompt},
        ],
        "temperature": 0.1,  # Low temperature for deterministic output
    }

    try:
        async with httpx.AsyncClient(timeout=30) as client:
            resp = await client.post(api_url, json=payload, headers=headers)

        if resp.status_code != 200:
            raise HTTPException(
                status_code=500,
                detail=f"LLM API error: status={resp.status_code}, body={resp.text}"
            )

        data = resp.json()
        content = data["choices"][0]["message"]["content"]
        return content.strip()
    except httpx.TimeoutException:
        raise HTTPException(status_code=504, detail="LLM API timeout")
    except Exception as e:
        logger.error(f"LLM call error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to call LLM: {str(e)}")


def _build_prompt(description: str, action_type: str) -> str:
    """Build prompt for LLM to generate Solana instruction"""
    return f"""
Generate a Solana program instruction for a commitment pool application.

User request: "{description}"
Action type: {action_type}

Available instruction types:
1. create_pool - Create a new commitment pool
   Required accounts:
     - pool_pubkey (PDA, derived from pool_id)
     - creator (signer)
     - system_program
   Data fields:
     - pool_id: int
     - name: string
     - stake_amount: float (in SOL)
     - duration_days: int
     - max_participants: int
     - goal_type: string (e.g., "hodl_token", "lifestyle_habit")
     - goal_metadata: object

2. join_pool - Join an existing pool
   Required accounts:
     - pool_pubkey
     - participant_pubkey (PDA, derived from pool + wallet)
     - participant_wallet (signer)
     - system_program
   Data fields:
     - pool_id: int
     - stake_amount: float

3. verify_participant - Verify participant progress (agent only)
   Required accounts:
     - pool_pubkey
     - participant_pubkey
     - verifier (signer)
   Data fields:
     - pool_id: int
     - participant_wallet: string
     - day: int
     - passed: boolean

4. distribute_rewards - Distribute pool rewards (agent only)
   Required accounts:
     - pool_pubkey
     - creator
     - system_program
   Data fields:
     - pool_id: int

Return JSON in this exact format:
{{
  "instruction_type": "create_pool",
  "accounts": [
    {{"name": "pool_pubkey", "pubkey": "PDA", "is_signer": false, "is_writable": true}},
    {{"name": "creator", "pubkey": "USER_WALLET", "is_signer": true, "is_writable": true}},
    {{"name": "system_program", "pubkey": "11111111111111111111111111111111", "is_signer": false, "is_writable": false}}
  ],
  "data": {{
    "pool_id": 1234567890,
    "name": "30-Day HODL Challenge",
    "stake_amount": 0.5,
    "duration_days": 30,
    "max_participants": 10,
    "goal_type": "hodl_token",
    "goal_metadata": {{"token_mint": "So11111111111111111111111111111111111111112", "min_balance": 1000000000}}
  }},
  "description": "Creates a 30-day HODL challenge for 0.5 SOL"
}}

Rules:
- Use realistic values based on the user's description
- For PDAs, use "PDA" as the pubkey (will be derived on-chain)
- For user wallet, use "USER_WALLET" (will be replaced with actual wallet)
- Ensure all required accounts are included
- Data fields must match the instruction type
- Return JSON ONLY, no markdown, no explanations
"""


def _build_challenge_prompt(description: str, challenge_type: str) -> str:
    """Build prompt for LLM to generate a ChallengeBlueprint."""
    return f"""
You are configuring a commitment challenge for the Commitment Parties protocol.

User provided this high-level description (verbatim, do not echo it back): "{description}"
The user selected this challenge category in the UI: "{challenge_type}".

Your job:
- Interpret what the user actually wants to commit to.
- Map it into our existing goal system (lifestyle_habit, hodl_token, github_commits, etc.).
- Propose concrete, reasonable defaults for stake, duration, recruitment period, and participants.
- Explain the verification rule in 1 short sentence a normal user can understand.

Allowed normalized challenge_type values:
- "lifestyle"  -> habits verified via photos/GPS/screenshots
- "crypto"     -> on-chain balance / hodl style goals
- "developer"  -> GitHub commit based challenges

Allowed goal_type values:
- "lifestyle_habit"
- "hodl_token"

For lifestyle_habit, goal_metadata examples:
- Simple photo habit:
  {{
    "habit_type": "lifestyle_photo",
    "habit_name": "6AM Gym Check-in",
    "proof_type": "photo_gps",              // photo | photo_gps | screenshot
    "checkin_window_start_hour_utc": 5,    // 0-23
    "checkin_window_end_hour_utc": 7,      // 0-23
    "min_checkins_per_day": 1,
    "summary": "Post a gym selfie with GPS between 5â€“7am every day."
  }}

- GitHub commits:
  {{
    "habit_type": "github_commits",
    "habit_name": "Daily GitHub Shipping",
    "min_commits_per_day": 1,
    "min_total_lines_per_day": 50,         // optional: total lines across all commits/repos
    "summary": "Ship at least 1 commit per day with at least 50 total lines of code changes."
  }}

For hodl_token, goal_metadata example:
{{
  "habit_type": "hodl_token",
  "token_mint": "So11111111111111111111111111111111111111112",
  "min_balance": 1000000000,
  "summary": "Hold at least 1 SOL in your wallet for the full challenge."
}}

Constraints (VERY IMPORTANT):
- suggested_stake_amount: 0.01 <= value <= 5.0 (SOL)
- suggested_duration_days: 3 <= value <= 60
- suggested_recruitment_hours: must be one of [0, 1, 24, 168]
- suggested_max_participants: 1 <= value <= 1000
- suggested_min_participants: 1 <= value <= suggested_max_participants

Return STRICT JSON ONLY with this exact shape:
{{
  "canonical_name": "string, <= 100 chars, title-case name of the pool",
  "short_description": "string, <= 200 chars, one-line human summary",
  "detailed_description": "optional longer copy for pool page",
  "challenge_type": "lifestyle | crypto | developer",
  "goal_type": "lifestyle_habit | hodl_token",
  "goal_metadata": {{ ... }},
  "suggested_stake_amount": 0.5,
  "suggested_duration_days": 30,
  "suggested_recruitment_hours": 24,
  "suggested_max_participants": 100,
  "suggested_min_participants": 10,
  "verification_summary": "short sentence explaining what a user must do each day",
  "tweet_hook": "very short catchy phrase for tweets, <= 80 chars"
}}

Rules:
- NEVER include comments or markdown, ONLY raw JSON.
- Use realistic, safe defaults if the description is vague.
- If the text clearly describes a GitHub/dev challenge, use challenge_type="developer" and habit_type="github_commits".
- If the text clearly describes a token hold/hodl goal, use challenge_type="crypto" and goal_type="hodl_token".
"""


@router.post(
    "/generate",
    response_model=OnChainActionResponse,
    summary="Generate on-chain action from natural language",
    description="Convert natural language description into Solana program instruction data",
)
async def generate_onchain_action(body: OnChainActionRequest) -> OnChainActionResponse:
    """Generate Solana instruction from natural language description"""
    try:
        prompt = _build_prompt(body.description, body.action_type)
        raw = await _call_llm(prompt)

        # Parse JSON response
        text = raw.strip()
        if text.startswith("```"):
            text = text.strip("`")
            brace_index = text.find("{")
            if brace_index != -1:
                text = text[brace_index:]

        try:
            data = json.loads(text)
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse LLM JSON: {raw}")
            raise HTTPException(
                status_code=500,
                detail=f"Failed to parse LLM response as JSON: {e}"
            )

        # Validate instruction structure
        if "instruction_type" not in data or "accounts" not in data or "data" not in data:
            raise HTTPException(
                status_code=500,
                detail="Invalid instruction structure from LLM"
            )

        instruction = InstructionData(
            instruction_type=data["instruction_type"],
            accounts=data["accounts"],
            data=data["data"],
            description=data.get("description", body.description),
        )

        # Estimate fee (base transaction fee + compute units)
        estimated_fee = 0.000005  # ~5000 lamports base fee

        # Determine required signer
        required_signer = "USER_WALLET"
        for acc in instruction.accounts:
            if acc.get("is_signer") and acc.get("name") != "system_program":
                required_signer = acc.get("pubkey", "USER_WALLET")
                break

        warnings = []
        if body.action_type == "create_pool" and instruction.data.get("stake_amount", 0) > 10:
            warnings.append("Stake amount exceeds recommended maximum (10 SOL)")
        if instruction.data.get("duration_days", 0) > 90:
            warnings.append("Duration exceeds recommended maximum (90 days)")

        return OnChainActionResponse(
            instruction=instruction,
            estimated_fee=estimated_fee,
            required_signer=required_signer,
            warnings=warnings,
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating on-chain action: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate on-chain action: {str(e)}"
        )


@router.post(
    "/challenges/parse",
    response_model=ChallengeBlueprint,
    summary="Parse natural language into a structured challenge blueprint",
    description=(
        "Takes a high-level challenge description and returns a structured blueprint "
        "with goal_type, goal_metadata, and suggested parameters for pool creation."
    ),
)
async def parse_challenge(body: ChallengeParseRequest) -> ChallengeBlueprint:
    """Generate a structured ChallengeBlueprint from natural language."""
    try:
        prompt = _build_challenge_prompt(body.description, body.challenge_type)
        raw = await _call_llm(prompt)

        text = raw.strip()
        if text.startswith("```"):
            text = text.strip("`")
            brace_index = text.find("{")
            if brace_index != -1:
                text = text[brace_index:]

        try:
            data = json.loads(text)
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse LLM JSON for challenge blueprint: {raw}")
            raise HTTPException(
                status_code=500,
                detail=f"Failed to parse LLM response as JSON: {e}",
            )

        # Basic validation & clamping for numeric fields
        stake = float(data.get("suggested_stake_amount", 0.5) or 0.5)
        stake = max(0.01, min(stake, 5.0))

        duration = int(data.get("suggested_duration_days", 14) or 14)
        duration = max(3, min(duration, 60))

        recruitment = int(data.get("suggested_recruitment_hours", 24) or 24)
        if recruitment not in (0, 1, 24, 168):
            recruitment = 24

        max_participants = int(data.get("suggested_max_participants", 100) or 100)
        max_participants = max(1, min(max_participants, 1000))

        min_participants = int(data.get("suggested_min_participants", 10) or 10)
        if min_participants < 1:
            min_participants = 1
        if min_participants > max_participants:
            min_participants = max_participants

        goal_metadata = data.get("goal_metadata") or {}

        # Ensure we always have a summary for UI/tweets
        verification_summary = data.get("verification_summary") or goal_metadata.get(
            "summary"
        )
        if not verification_summary and isinstance(goal_metadata, dict):
            habit_name = goal_metadata.get("habit_name") or goal_metadata.get(
                "habit_type"
            )
            if habit_name:
                verification_summary = f"Stay consistent with: {habit_name}."

        # Merge back into data so Pydantic model validation is applied uniformly
        data["suggested_stake_amount"] = stake
        data["suggested_duration_days"] = duration
        data["suggested_recruitment_hours"] = recruitment
        data["suggested_max_participants"] = max_participants
        data["suggested_min_participants"] = min_participants
        data["goal_metadata"] = goal_metadata
        data["verification_summary"] = verification_summary

        try:
            blueprint = ChallengeBlueprint(**data)
        except Exception as e:
            logger.error(f"Invalid blueprint structure from LLM: {data}", exc_info=True)
            raise HTTPException(
                status_code=500,
                detail=f"LLM returned invalid blueprint structure: {e}",
            )

        return blueprint

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating challenge blueprint: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate challenge blueprint: {str(e)}",
        )


